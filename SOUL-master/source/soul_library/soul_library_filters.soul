/*
    _____ _____ _____ __
   |   __|     |  |  |  |      The SOUL language
   |__   |  |  |  |  |  |__    Copyright (c) 2019 - ROLI Ltd.
   |_____|_____|_____|_____|

   The code in this file is provided under the terms of the ISC license:

   Permission to use, copy, modify, and/or distribute this software for any purpose
   with or without fee is hereby granted, provided that the above copyright notice and
   this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

/** Title: Filters

    This module contains a collection of filter implementations, including more traditional
    biquad based filters and TPT variants, which are more suitable for modulation.

    Notes:
    - Filter coefficients are typically labelled a and b. Different literature uses different
      conventions for what a and b mean. This code uses the following:
        * `b`: feed-forward, numerator, zero, FIR coefficients.
        * `a`: feed-back, denominator, pole, IIR coefficients.
    - Although each filter comes with a Processor, they are designed so that their state,
      coefficients and functions can be used independently.
    - Each filter has a `State` struct and a `Coeffs` struct.
    - `process()` functions generate an output y for an input x.
    - `update()` functions take high level parameters such as mode, frequency, Q, mode and
      update the filter coefficients.
    - `reset()` functions reset the filter state/histories to 0.
    - `clear()` functions clears filter coefficients.
    - The filters are designed for channel-wise vectorisation, which can be achieved by
      specialising the filter's namespace with a vector type.
    - Some filters are suitable for modulation, others are not, check the comments at the top
      of the namespace.
*/

namespace soul::filters (using SampleType = float32,
                         using CoeffType  = float64,
                         int updateInterval = 16)
{
    // Processor parameter min/max/defaults
    let minFreqHz = 5.0f;
    let maxFreqHz = 22000.0f;
    let defaultFreqHz = 1000.0f;
    let defaultQuality = 0.707107f; // 1.0 / sqrt (2.0) butterworth response
    let defaultGain = 0.f;

    /** The frequency upper-bound for update functions.
        (Just below nyquist, e.g 0.49 * 44100 = ~22kHz).
    */
    let normalisedFreqLimit = 0.49;

    //==============================================================================
    /** Highpass filter for removing DC offset.

            y[n] = x[n] - x[n-1] + b0 * y[n-1]

        https://ccrma.stanford.edu/~jos/fp/DC_Blocker.html
    */
    namespace dc_blocker
    {
        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            CoeffType b1;
            CoeffType a0;
        }

        /** Holds the filter state. */
        struct State
        {
            SampleType[1] x;
            SampleType[1] y;
        }

        /** Resets a filter state. */
        void reset (State& s)
        {
            s.x[0] = SampleType();
            s.y[0] = SampleType();
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, float64 sampleRate, float64 freqHz)
        {
            let w = pi * freqHz / sampleRate;
            c.a0 = CoeffType (1.0 / (1.0 + w));
            c.b1 = CoeffType ((1.0 - w) * c.a0);
        }

        SampleType process (State& s, SampleType x, Coeffs& c)
        {
            let y = SampleType (x - s.x[0] + c.a0 * s.y[0]);
            s.x[0] = x;
            s.y[0] = y;
            return SampleType (c.b1 * y);
        }

        processor Processor (float64 frequency = 30.0f)
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                State s;
                Coeffs c;

                c.update (processor.frequency, frequency);

                loop
                {
                    out << s.process (in, c);
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Biquadratic (two-pole-two-zero) IIR filter building block.

        Direct Form I (DFI):

            y[n] = b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] - a1 * y[n-1] - a2 * y[n-2]

        Transposed Direct Form II (TDFII):

            y[n] = b0 * x[n] + s1
            s1 = b1 * x[n] + a1 * y[n] + s2
            s2 = b2 * x[n] + a2 * y[n]
    */
    namespace biquad
    {
        // Coefficients and related functions

        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            CoeffType<3> b, /**< feed-forward, numerator, zero, FIR coefficients */
                         a; /**< feed-back, denominator, pole, IIR coefficients */
        }

        /** Initialises a set of coefficients. */
        void set (Coeffs &c,
                  CoeffType b0, CoeffType b1, CoeffType b2,
                  CoeffType a0, CoeffType a1, CoeffType a2)
        {
            c.b[0] = b0; c.b[1] = b1; c.b[2] = b2; c.a[0] = a0; c.a[1] = a1; c.a[2] = a2;
        }

        /** Sets the coefficients, normalising based on the first feedback coefficient v.a[0] */
        void setNonNormalised (Coeffs &c, const Coeffs& v)
        {
            let oneOverA0 = 1.0 / v.a[0];
            c.b = v.b * oneOverA0;
            c.a = v.a * oneOverA0;
            c.a[0] = v.a[0]; // keep original a0
        }

        /** Sets the coefficients, assuming v is already normalised. */
        void setNormalised (Coeffs &c, Coeffs v)
        {
            c = v;
        }

        /** Clears a set of coefficients. */
        void clear (Coeffs &c)
        {
            c.b = CoeffType();
            c.a = CoeffType();
        }

        /** Holds the filter state. */
        struct State
        {
            SampleType[2] x;
            SampleType[2] y;
        }

        /** Resets a filter state. */
        void reset (State &s)
        {
            s.x[0] = SampleType();
            s.x[1] = SampleType();
            s.y[0] = SampleType();
            s.y[1] = SampleType();
        }

        /** */
        SampleType processDFI (State& s, SampleType x, Coeffs& c)
        {
            let y  = SampleType (c.b[0] * x
                               + c.b[1] * s.x[0]
                               + c.b[2] * s.x[1]
                               - c.a[1] * s.y[0]
                               - c.a[2] * s.y[1]);

            s.x[1] = s.x[0];
            s.x[0] = x;
            s.y[1] = s.y[0];
            s.y[0] = y;

            return y;
        }

        /** See https://www.earlevel.com/DigitalAudio/images/BiquadTDFII.gif */
        SampleType processTDFII (State& s, SampleType x, Coeffs& c)
        {
            let y  = s.x[0] + SampleType (c.b[0]) * x;
            s.x[0] = s.y[0] + SampleType (c.b[1]) * x - SampleType (c.a[1]) * y;
            s.y[0] = SampleType (c.b[2]) * x - SampleType (c.a[2]) * y;
            return y;
        }

        /** Like processTDFII, but optimised for c.b[2] and c.a[2] == 0. */
        SampleType processOnePole (State& s, SampleType x, Coeffs& c)
        {
            let y  = s.x[0] + SampleType (c.b[0]) * x;
            s.x[0] = SampleType (c.b[1]) * x - SampleType (c.a[1]) * y;
            return y;
        }

        /** */
        SampleType processCascadeDFI<StateArrayType, CoeffsArrayType> (SampleType x,
                                                                       StateArrayType& s,
                                                                       CoeffsArrayType& c)
        {
            static_assert (StateArrayType.isArray, "states argument is not an array");
            static_assert (CoeffsArrayType.isArray, "coeffs argument is not an array");
            static_assert (s.size == c.size, "states and coeffs arrays are not the same size");

            var y = x;

            for (wrap<s.size> i)
                y = processDFI (s[i], y, c[i]);

            return y;
        }

        /** */
        SampleType processCascadeTDFII<StateArrayType, CoeffsArrayType> (SampleType x,
                                                                         StateArrayType& s,
                                                                         CoeffsArrayType& c)
        {
            static_assert (StateArrayType.isArray, "states argument is not an array");
            static_assert (CoeffsArrayType.isArray, "coeffs argument is not an array");
            static_assert (s.size == c.size, "states and coeffs arrays are not the same size");

            var y = x;

            for (wrap<s.size> i)
                y = processTDFII (s[i], y, c[i]);

            return y;
        }
    }

    //==============================================================================
    /**
        First-order IIR filter.

            y[n] = b0 * x[n] - a1 * y[n-1]

        Coefficients derived from Pirkle.
        This filter is not suitable for modulation.
    */
    namespace onepole
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let lowpass  = 0;
            let highpass = 1;
            let allpass  = 2;
        }

        /** Updates a set of coefficients for the given settings. */
        void update (biquad::Coeffs& c, float64 sampleRate, int mode, float64 freqHz)
        {
            biquad::Coeffs nc; // normalised coefficients
            nc.a[0] = 1.0;

            let theta = twoPi * (freqHz / sampleRate);

            if (mode == Mode::lowpass)
            {
                let gamma = CoeffType (cos (theta) / (1.0 + sin (theta)));

                nc.b[0] = (1 - gamma) / 2;
                nc.b[1] = (1 - gamma) / 2;
                nc.a[1] = -gamma;
            }
            else if (mode == Mode::highpass)
            {
                let gamma = CoeffType (cos (theta) / (1.0 + sin (theta)));

                nc.b[0] = (1 + gamma) / 2;
                nc.b[1] = -(1 + gamma) / 2;
                nc.a[1] = -gamma;
            }
            else if (mode == Mode::allpass)
            {
                let w = CoeffType (tan (theta * 0.5));
                let alpha = (w - 1) / (w + 1);

                nc.b[0] = alpha;
                nc.b[1] = 1.0;
                nc.a[1] = alpha;
            }

            c.setNormalised (nc);
        }

        /** A processor to render a onepole filter. */
        processor Processor (int initialMode = 0,
                             float initialFrequency = defaultFreqHz)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event
            {
                float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                float modeIn      [[ name: "Mode",      min: 0,           max: 2,         init: 0,         text: "Lowpass|Highpass|Allpass"]];
            }

            event frequencyIn (float v)   { frequency = v;  recalc = true; }
            event modeIn      (float v)   { mode = int (v); recalc = true; }

            float frequency  = initialFrequency;
            int   mode       = initialMode;
            bool  recalc     = true;

            void run()
            {
                biquad::State s;
                biquad::Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
                        let clippedFrequency = clamp (float64 (frequency),
                                                      float64 (minFreqHz),
                                                      processor.frequency * normalisedFreqLimit);
                        update (c, processor.frequency, mode, clippedFrequency);
                    }

                    loop (updateInterval)
                    {
                        out << s.processOnePole (in, c);
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** RBJ biquad EQ, 2nd Order IIR Filter.

        This filter is not suitable for modulation.
        See https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html
    */
    namespace rbj_eq
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let lowpass   = 0;
            let highpass  = 1;
            let bandpass  = 2;
            let lowShelf  = 3;
            let highShelf = 4;
            let peaking   = 5;
            let notch     = 6;
            let allpass   = 7;
        }

        /** Updates a set of coefficients for the given settings. */
        void update (biquad::Coeffs& c,
                     float64 sampleRate, int mode, float64 freqHz,
                     float64 quality, float64 gaindB)
        {
            biquad::Coeffs nnc; // non-normalised coefficients

            let theta = CoeffType (twoPi * (freqHz / sampleRate));
            let sinTheta = sin (theta);
            let cosTheta = cos (theta);
            let Q = max (quality, 0.001);
            let alpha = CoeffType (sinTheta / (2.0 * Q));

            if (mode == Mode::lowpass)
            {
                nnc.b[0] = (1 - cosTheta) / 2;
                nnc.b[1] =  1 - cosTheta;
                nnc.b[2] = (1 - cosTheta) / 2;
                nnc.a[0] =  1 + alpha;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] =  1 - alpha;
            }
            else if (mode == Mode::highpass)
            {
                nnc.b[0] = (1 + cosTheta) / 2;
                nnc.b[1] = -(1 + cosTheta);
                nnc.b[2] = (1 + cosTheta) / 2;
                nnc.a[0] =  1 + alpha;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] =  1 - alpha;
            }
            else if (mode == Mode::bandpass) // (constant 0 dB peak gain)
            {
                nnc.b[0] = alpha;
                nnc.b[1] = 0;
                nnc.b[2] = -alpha;
                nnc.a[0] =  1 + alpha;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] =  1 - alpha;
            }
            else if (mode == Mode::lowShelf)
            {
                let A = CoeffType (pow (10.0, gaindB / 40.0));
                nnc.b[0] = A * ((A + 1) - (A - 1) * cosTheta + 2 * sqrt (A) * alpha);
                nnc.b[1] = 2 * A * ( (A - 1) - (A + 1) * cosTheta);
                nnc.b[2] = A * ((A + 1) - (A - 1) * cosTheta - 2 * sqrt (A) * alpha);
                nnc.a[0] = (A + 1) + (A - 1) * cosTheta + 2 * sqrt (A) * alpha;
                nnc.a[1] = -2 * ( (A - 1) + (A + 1) * cosTheta);
                nnc.a[2] = (A + 1) + (A - 1) * cosTheta - 2 * sqrt (A) * alpha;
            }
            else if (mode == Mode::highShelf)
            {
                let A = CoeffType (pow (10.0, gaindB / 40.0));
                nnc.b[0] = A * ((A + 1) + (A - 1) * cosTheta + 2 * sqrt (A) * alpha);
                nnc.b[1] = -2 * A * ( (A - 1) + (A + 1) * cosTheta);
                nnc.b[2] = A * ((A + 1) + (A - 1) * cosTheta - 2 * sqrt (A) * alpha);
                nnc.a[0] = (A + 1) - (A - 1) * cosTheta + 2 * sqrt (A) * alpha;
                nnc.a[1] = 2 * ( (A - 1) - (A + 1) * cosTheta);
                nnc.a[2] = (A + 1) - (A - 1) * cosTheta - 2 * sqrt (A) * alpha;
            }
            else if (mode == Mode::peaking)
            {
                let A = CoeffType (pow (10.0, gaindB / 40.0));
                nnc.b[0] = 1 + alpha * A;
                nnc.b[1] = -2 * cosTheta;
                nnc.b[2] = 1 - alpha * A;
                nnc.a[0] = 1 + alpha / A;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] = 1 - alpha / A;
            }
            else if (mode == Mode::notch)
            {
                nnc.b[0] = 1;
                nnc.b[1] = -2 * cosTheta;
                nnc.b[2] = 1;
                nnc.a[0] = 1 + alpha;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] = 1 - alpha;
            }
            else if (mode == Mode::allpass)
            {
                nnc.b[0] = 1 - alpha;
                nnc.b[1] = -2 * cosTheta;
                nnc.b[2] = 1 + alpha;
                nnc.a[0] = 1 + alpha;
                nnc.a[1] = -2 * cosTheta;
                nnc.a[2] = 1 - alpha;
            }

            c.setNonNormalised (nnc);
        }

        /** */
        processor Processor (int initialMode = 0,
                             float initialFrequency = defaultFreqHz,
                             float initialQuality   = defaultQuality,
                             float initialGain      = defaultGain)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event
            {
                float modeIn      [[ name: "Mode",      min: 0,           max: 7,         init: 0,         text: "Lowpass|Highpass|Bandpass|LowShelf|HighShelf|Peaking|Notch|Allpass"]];
                float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                float qualityIn   [[ name: "Q",         min: 0.,          max: 10.0,      init: defaultQuality]];
                float gainIn      [[ name: "Gain",      min: -36.0,       max: 36.0,      init: defaultGain, unit: "dB"]];
            }

            event frequencyIn (float v) { frequency = v;   recalc = true; }
            event qualityIn   (float v) { quality = v;     recalc = true; }
            event gainIn      (float v) { gain = v;        recalc = true; }
            event modeIn      (float v) { mode = int (v);  recalc = true; }

            float  frequency = initialFrequency;
            float  quality   = initialQuality;
            float  gain      = initialGain;
            int    mode      = initialMode;
            bool   recalc    = true;

            void run()
            {
                biquad::State s;
                biquad::Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
                        let clippedFrequency = clamp (float64 (frequency), float64 (minFreqHz), processor.frequency * normalisedFreqLimit);
                        c.update (processor.frequency, mode, clippedFrequency, quality, gain);
                    }

                    loop (updateInterval)
                    {
                        out << s.processTDFII (in, c);
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /**
        Generic second-order-section cascade biquad processors.
    */
    namespace sos_cascade
    {
        /** Supply an array of coefficients for each SOS. The size of the array should be a multiple of 6,
            and the coefficients are expected to be normalised already
        */
        processor Processor (const CoeffType[] coeffs)
        {
            input stream SampleType in;
            output stream SampleType out;

            let numSOS = size (coeffs) / 6;
            biquad::State[numSOS] s;
            biquad::Coeffs[numSOS] c;

            void init()
            {
                static_assert (size (coeffs) % 6 == 0, "coeffs is not a multiple of 6");

                wrap<numSOS> section = 0;
                wrap<coeffs.size> coeffIdx = 0;

                loop (numSOS)
                {
                    // TODO: replace with dynamic array slice
                    biquad::set (c[section], coeffs[wrap<coeffs.size> (coeffIdx + 0)],
                                             coeffs[wrap<coeffs.size> (coeffIdx + 1)],
                                             coeffs[wrap<coeffs.size> (coeffIdx + 2)],
                                             coeffs[wrap<coeffs.size> (coeffIdx + 3)],
                                             coeffs[wrap<coeffs.size> (coeffIdx + 4)],
                                             coeffs[wrap<coeffs.size> (coeffIdx + 5)]);
                    section++;
                    coeffIdx += 6;
                }
            }

            void run()
            {
                loop
                {
                    out << biquad::processCascadeTDFII (in, s, c);
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /**
        N-th order Butterworth filter, made by cascading multiple second order sections.

        This filter is not suitable for modulation.
    */
    namespace butterworth
    {
        // namespace biquad = soul::filters::biquad;
        // namespace onepole = soul::filters::onepole;
        // namespace rbj = soul::filters::rbj_eq;

        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let lowpass  = 0;
            let highpass = 1;
        }

        /** Updates a set of coefficients for the given settings. */
        void update<CoeffsArrayType> (CoeffsArrayType& coeffs, float64 sampleRate, int order, int mode, float64 freqHz)
        {
            static_assert (CoeffsArrayType.isArray, "coeffs argument is not an array");

            biquad::Coeffs nc; // normalised coefficients

            bool oddOrder = (order % 2) == 1;

            if (oddOrder)
            {
                onepole::update (nc, sampleRate, mode, freqHz);
                coeffs.at (0).setNormalised (nc);

                for (int i=0; i<order/2; i++)
                {
                    let Q = 1.0 / (2.0 * cos ((CoeffType (i) + 1.0) * pi / order));
                    rbj_eq::update (nc, sampleRate, mode, freqHz, Q, 0.);
                    coeffs.at (i+1).setNormalised (nc);
                }
            }
            else
            {
                for (wrap<coeffs.size> i)
                {
                    let Q = 1.0 / (2.0 * cos ((2.0 * CoeffType (i) + 1.0) * pi / (order * 2.0)));
                    rbj_eq::update (nc, sampleRate, mode, freqHz, Q, 0.);
                    coeffs.at (i).setNormalised (nc);
                }
            }
        }

        /** Butterworth processor.
            The order must be > 0
        */
        processor Processor (int order,
                             int initialMode = 0,
                             float initialFrequency = defaultFreqHz)
        {
            input stream SampleType in;
            output stream SampleType out;

            input event
            {
                float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                float modeIn      [[ name: "Mode",      min: 0,           max: 1,         init: 0,         text: "Lowpass|Highpass"]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event modeIn      (float v) { mode = int (v); recalc = true; clear = true; }

            float frequency = initialFrequency;
            int mode = initialMode;
            bool recalc = true;
            bool clear = true;

            void run()
            {
                let numSOS = (order / 2) + (order % 2);
                biquad::State[numSOS] s;
                biquad::Coeffs[numSOS] c;

                loop
                {
                    if (recalc)
                    {
                        if (clear) // mode change requires clearing histories
                        {
                            for (wrap<s.size> i)
                            {
                                biquad::reset (s[i]);
                            }
                        }

                        recalc = false;
                        let clippedFrequency = clamp (float64 (frequency), float64 (minFreqHz), processor.frequency * normalisedFreqLimit);
                        update (c, processor.frequency, order, mode, clippedFrequency);
                    }

                    loop (updateInterval)
                    {
                        out << biquad::processCascadeTDFII (in, s, c);
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Analytic filter / IIR Hilbert transformer.

        https://dsp.stackexchange.com/a/59157

        Increasing numFilters will increase the accuracy of the quadrature output across the
        pass band but introduce more delay with respect to the input signal.
        The filter passband is from transitionBandwidthHz to nyquist - transitionBandwidthHz.
    */
    namespace analytic (int numFilters = 6,
                        float transitionBandwidthHz = 20.0f)
    {
        /** Polyphase IIR Designer.
            Based on HIIR http://ldesoras.free.fr/prod.html#src_hiir
        */
        namespace polyphase_iir_design
        {
            let numCoefficients = numFilters * 2;
            let order = numCoefficients * 2 + 1;

            /** Holds a set of filter coefficients. */
            struct Coeffs
            {
                CoeffType[numCoefficients] coeffs;
            }

            /** */
            Coeffs compute (float64 transition)
            {
                Coeffs c;

                let p = computeTransitionParam (transition);

                for (wrap<numCoefficients> i)
                    c.coeffs.at (i) = computeCoeff (i, p);

                return c;
            }

            struct TransitionParams
            {
                float64 k, q;
            }

            TransitionParams computeTransitionParam (float64 transition)
            {
                var k = tan ((1.0 - transition * 2.0) * (pi / 4));
                k *= k;
                let kksqrt = pow (1.0 - k * k, 0.25);
                let e = 0.5 * (1.0 - kksqrt) / (1 + kksqrt);
                let e2 = e * e;
                let e4 = e2 * e2;
                let q = e * (1.0 + e4 * (2.0 + e4 * (15.0 + 150.0 * e4)));

                return TransitionParams (k, q);
            }

            float64 computeAccNum (float64 q, int c)
            {
                float64 result, i = 0, j = 1;

                loop
                {
                    let next = pow (q, float64 (i * (i + 1))) * sin ((i * 2 + 1) * c * pi / order) * j;
                    result += next;

                    if (abs (next) < 1e-100)
                        return result;

                    j = -j;
                    i++;
                }
            }

            float64 computeAccDen (float64 q, int c)
            {
                float64 result, i = 1.0, j = -1.0;

                loop
                {
                    let next = pow (q, (i * i)) * cos (i * 2 * c * pi / order) * j;
                    result += next;

                    if (abs (next) < 1e-100)
                        return result;

                    j = -j;
                    i = i + 1.0;
                }
            }

            CoeffType computeCoeff (int index, TransitionParams params)
            {
                let num = computeAccNum (params.q, index + 1)  * pow (params.q, 0.25);
                let den = computeAccDen (params.q, index + 1) + 0.5;
                let ww = num / den;
                let wwsq = CoeffType (ww * ww);

                let x = CoeffType (sqrt ((1 - wwsq * params.k) * (1 - wwsq / params.k)) / (1 + wwsq));
                return (1 - x) / (1 + x);
            }
        }

        /** Parallel 2nd-order all-pass.

                y[n] = c * (x[n] + y[n - 2]) - x[n - 2]
        */
        namespace dual_apf
        {
            /** Holds the filter state. */
            struct State
            {
                SampleType[2] x1, y1, x2, y2;
                CoeffType[2] c;
            }

            /** */
            SampleType[2] process (State& s, SampleType[2] x)
            {
                let y = SampleType[2] (SampleType (s.c[0]) * (x[0] + s.y2[0]) - s.x2[0],
                                       SampleType (s.c[1]) * (x[1] + s.y2[1]) - s.x2[1]);
                s.x2 = s.x1;
                s.x1 = x;
                s.y2 = s.y1;
                s.y1 = y;

                return y;
            }
        }

        /** Holds the filter state. */
        struct State
        {
            dual_apf::State[numFilters] apfs;
            SampleType[1] x;
        }

        /** Updates a filter state with the given sample rate. */
        void update (State& s, float64 sampleRate)
        {
            let design = polyphase_iir_design::compute (2.0 * (transitionBandwidthHz / sampleRate));

            for (wrap<numFilters> i)
            {
                s.apfs.at (i).c[0] = design.coeffs.at (i * 2);
                s.apfs.at (i).c[1] = design.coeffs.at (i * 2 + 1);
            }
        }

        /** */
        SampleType[2] process (State& s, SampleType x)
        {
            var y = SampleType[2] (x, s.x[0]);

            for (wrap<numFilters> i)
            {
                y = s.apfs[i].process (y);
            }

            s.x[0] = x;
            return y;
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType realOut;
            output stream SampleType imagOut;

            State s;

            void init()
            {
                s.update (processor.frequency);
            }

            void run()
            {
                loop
                {
                    let y = s.process (in);
                    realOut << y[0];
                    imagOut << y[1];
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Complex Resonator filter.

        See https://ccrma.stanford.edu/~jos/smac03maxjos/smac03maxjos.pdf
        This filter is suitable for modulation
    */
    namespace complex_resonator
    {
        /** Holds the filter state. */
        struct State
        {
            SampleType yReal;
            SampleType yImag;
        }

        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            complex64 v;
        }

        complex64 cexp (complex64 c)
        {
            // TODO: if cexp becomes a global function, use that
            let e = exp (c.real);
            return complex64 (e * cos (c.imag), e * sin (c.imag));
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, float64 sampleRate, float64 freqHz, float64 t60)
        {
            let jImag = (0.0 + 1.0i);
            let decayFactor = tau2pole (t60, sampleRate);
            let oscCoef = cexp ((jImag * twoPi) * (freqHz / sampleRate));
            c.v = decayFactor * oscCoef;
        }

        /** */
        SampleType[2] process (State& s, Coeffs& c, SampleType x)
        {
            let xReal = x;
            let xImag = SampleType();
            let vReal = SampleType (c.v.real);
            let vImag = SampleType (c.v.imag);
            let yReal = xReal + ((vReal * s.yReal) - (vImag * s.yImag));
            let yImag = xImag + ((vReal * s.yImag) + (vImag * s.yReal));
            s.yReal = yReal;
            s.yImag = yImag;
            return SampleType[2] (yReal, yImag);
        }

        /** */
        processor Processor (float initialFrequency = defaultFreqHz,
                             float initialDecay = 1.0f,
                             float initialGain = 1.0f)
        {
            input stream SampleType in;
            output stream SampleType realOut;
            output stream SampleType imagOut;

            input event
            {
                float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                float decayIn     [[ name: "Decay",     min: 0.01,        max: 10.0,      init: 1.0, unit: "Seconds"]];
                float gainIn      [[ name: "Gain",      min: 0.01,        max: 10.0,      init: 1.0]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event decayIn     (float v) { decay = v; recalc = true; }
            event gainIn      (float v) { gain = v; recalc = true; }

            float frequency = initialFrequency,
                      decay = initialDecay,
                       gain = initialGain;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                dc_blocker::Coeffs dcc;
                dc_blocker::State realDCBlocker, imagDCBlocker;

                dcc.update (processor.frequency, 30.0f);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
                        let clippedFrequency = clamp (float64 (frequency), float64 (minFreqHz), processor.frequency * normalisedFreqLimit);
                        c.update (processor.frequency, clippedFrequency, decay);
                    }

                    loop (updateInterval)
                    {
                        let y = s.process (c, in);
                        realOut << realDCBlocker.process (y[0] * gain, dcc);
                        imagOut << imagDCBlocker.process (y[1] * gain, dcc);
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /**
        This namespace contains a set of "Topology preserving transform" filters.
    */
    namespace tpt
    {
        //==============================================================================
        /** "Topology preserving transform" one-pole filter.

            Derived from work by Zavalishin and Pirkle.
            This filter is suitable for modulation.
        */
        namespace onepole
        {
            /** Constants for use in specifying the filter mode. */
            namespace Mode
            {
                let lowpass  = 0;
                let highpass = 1;
                let allpass  = 2;
            }

            /** Holds a set of filter coefficients. */
            struct Coeffs
            {
                CoeffType b;
            }

            /** Holds the filter state. */
            struct State
            {
                SampleType z1;
            }

            /** Clears a set of coefficients. */
            void clear (Coeffs& c)
            {
                c.b = CoeffType (1);
            }

            /** Resets a filter state. */
            void reset (State& s)
            {
                s.z1 = SampleType();
            }

            /** Updates a set of coefficients for the given settings. */
            void update (Coeffs& c, float64 sampleRate, float64 freqHz)
            {
                let wd = twoPi * freqHz;
                let T  = 1.0 / sampleRate;
                let wa = (2.0 / T) * tan (wd * T / 2.0);
                let g  = wa * T / 2.0;

                c.b = CoeffType (g / (1.0 + g));
            }

            /** */
            SampleType processLPF (State& s, SampleType x, Coeffs& c)
            {
                let vn = (x - s.z1) * SampleType (c.b);
                let lpf = vn + s.z1;
                s.z1 = vn + lpf;
                return lpf;
            }

            /** */
            SampleType processHPF (State& s, SampleType x, Coeffs& c)
            {
                return x - processLPF (s, x, c);
            }

            /** */
            SampleType processAPF (State& s, SampleType x, Coeffs& c)
            {
                let lpf = processLPF (s, x, c);
                let hpf = x - lpf;
                return lpf - hpf;
            }

            /** */
            processor Processor (int initialMode = 0,
                                 float initialFrequency = defaultFreqHz)
            {
                input stream SampleType in;
                output stream SampleType out;

                input event
                {
                    float frequencyIn [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                    float modeIn      [[ name: "Mode",      min: 0,         max: 2,         init: 0,         text: "Lowpass|Highpass|Allpass"]];
                }

                event frequencyIn (float v) { frequency = v; recalc = true; }
                event modeIn      (float v) { mode = int (v); recalc = true; }

                float frequency = initialFrequency;
                int mode = initialMode;
                bool recalc = true;

                void run()
                {
                    State s;
                    Coeffs c;
                    c.clear ();

                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
                            let clippedFrequency = clamp (float64 (frequency),
                                                          float64 (minFreqHz),
                                                          processor.frequency * normalisedFreqLimit);
                            c.update (processor.frequency, clippedFrequency);
                        }

                        loop (updateInterval)
                        {
                            if (mode == Mode::lowpass)        out << s.processLPF (in, c);
                            else if (mode == Mode::highpass)  out << s.processHPF (in, c);
                            else if (mode == Mode::allpass)   out << s.processAPF (in, c);

                            advance();
                        }
                    }
                }
            }
        }

        //==============================================================================
        /** "Topology preserving transform" multi-mode state variable filter (SVF).

            Derived from work by Zavalishin and Pirkle.
            This filter is suitable for modulation.
        */
        namespace svf
        {
            /** Constants for use in specifying the filter mode. */
            namespace Mode
            {
                let lowpass  = 0;
                let highpass = 1;
                let bandpass = 2;
            }

            /** Holds a set of filter coefficients. */
            struct Coeffs
            {
                CoeffType a0;
                CoeffType a;
                CoeffType p;
            }

            /** Holds the filter state. */
            struct State
            {
                SampleType[2] z;
            }

            /** Resets a filter state. */
            void reset (State& s)
            {
                s.z[0] = SampleType();
                s.z[1] = SampleType();
            }

            /** Updates a set of coefficients for the given settings. */
            void update (Coeffs& c, float64 sampleRate, float64 freqHz, float64 quality)
            {
                let Q = CoeffType (max (quality, 0.001));
                let wd = CoeffType (twoPi * freqHz);
                let T  = CoeffType (1 / sampleRate);
                let wa = (2 / T) * tan (wd * T / 2);
                let g  = wa * T / 2;
                let R = 1 / (2 * Q);
                c.a0 = 1 / (1 + 2 * R * g + g * g);
                c.a = g;
                c.p = 2 * R + g;
            }

            /** */
            SampleType[3] process (State& s, SampleType x, Coeffs& c)
            {
                let hpf = SampleType (c.a0 * (x - c.p * s.z[0] - s.z[1]));
                let bpf = SampleType (c.a * hpf + s.z[0]);
                let lpf = SampleType (c.a * bpf + s.z[1]);

                s.z[0] = SampleType (c.a * hpf + bpf);
                s.z[1] = SampleType (c.a * bpf + lpf);

                return SampleType[3] (lpf, hpf, bpf);
            }

            /** */
            processor Processor (float initialFrequency = defaultFreqHz,
                                 float initialQuality = defaultQuality)
            {
                input stream SampleType in;
                output stream SampleType lowpassOut, bandpassOut, highpassOut;

                input event
                {
                    float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                    float qualityIn   [[ name: "Q",         min: 0.01,        max: 100.0,     init: defaultQuality]];
                }

                event frequencyIn (float v) { frequency = v; recalc = true; }
                event qualityIn   (float v) { quality = v; recalc = true; }

                float frequency = initialFrequency,
                        quality = initialQuality;
                bool recalc = true;

                void run()
                {
                    State s;
                    Coeffs c;

                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
                            let clippedFrequency = clamp (float64 (frequency),
                                                          float64 (minFreqHz),
                                                          processor.frequency * normalisedFreqLimit);
                            c.update (processor.frequency, clippedFrequency, quality);
                        }

                        loop (updateInterval)
                        {
                            let y = s.process (in, c);
                            lowpassOut  << y[0];
                            highpassOut << y[1];
                            bandpassOut << y[2];
                            advance();
                        }
                    }
                }
            }
        }

        //==============================================================================
        /**
            N-th order Butterworth filter, made by cascading TPT filters.
            This filter is suitable for modulation
        */
        namespace butterworth
        {
            /** Constants for use in specifying the filter mode. */
            namespace Mode
            {
                let lowpass  = 0;
                let highpass = 1;
            }

            /** Updates a set of coefficients for the given settings. */
            void update<SVFCoeffsArrayType> (SVFCoeffsArrayType& svfCoeffs,
                                             onepole::Coeffs& onepoleCoeffs,
                                             float64 sampleRate, int order, float64 freqHz)
            {
                static_assert (SVFCoeffsArrayType.isArray, "coeffs argument is not an array");

                bool oddOrder = (order % 2) == 1;

                if (oddOrder)
                {
                    onepole::update (onepoleCoeffs, sampleRate, freqHz);

                    for (wrap<svfCoeffs.size> i)
                    {
                        let Q = 1.0 / (2.0 * cos ((CoeffType (i) + 1.0) * pi / order));
                        svf::update (svfCoeffs.at (i), sampleRate, freqHz, Q);
                    }
                }
                else
                {
                    for (wrap<svfCoeffs.size> i)
                    {
                        let Q = 1.0 / (2.0 * cos ((2.0 * CoeffType (i) + 1.0) * pi / (order * 2.0)));
                        svf::update (svfCoeffs.at (i), sampleRate, freqHz, Q);
                    }
                }
            }

            /** */
            SampleType process<StateArrayType, CoeffsArrayType> (SampleType x,
                                                                 StateArrayType& svfStates,
                                                                 CoeffsArrayType& svfCoeffs,
                                                                 onepole::State& onepoleState,
                                                                 onepole::Coeffs& onepoleCoeffs,
                                                                 int mode, bool oddOrder)
            {
                static_assert (StateArrayType.isArray, "states argument is not an array");
                static_assert (CoeffsArrayType.isArray, "coeffs argument is not an array");
                static_assert (svfStates.size == svfCoeffs.size, "states and coeffs arrays are not the same size");

                var y = x;

                if (oddOrder)
                {
                    if (mode == Mode::lowpass)
                        y = onepoleState.processLPF (y, onepoleCoeffs);
                    else if (mode == Mode::highpass)
                        y = onepoleState.processHPF (y, onepoleCoeffs);
                }

                for (wrap<svfStates.size> i)
                    y = svf::process (svfStates[i], y, svfCoeffs[i])[wrap<2> (mode)]; // TODO: tidy this

                return y;
            }

            /* Butterworth processor.
               The order must be > 1
            */
            processor Processor (int order,
                                 int initialMode = 0,
                                 float initialFrequency = defaultFreqHz)
            {
                input stream SampleType in;
                output stream SampleType out;

                input event
                {
                    float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                    float modeIn      [[ name: "Mode",      min: 0,           max: 1,         init: 0,         text: "Lowpass|Highpass"]];
                }

                event frequencyIn (float v)   { frequency = v; recalc = true; }
                event modeIn      (float v)   { mode = int (v); recalc = true; }

                float  frequency  = initialFrequency;
                int    mode       = initialMode;
                bool   recalc     = true;

                void run()
                {
                    let numSVFs = order / 2;
                    let oddOrder = (order % 2) == 1;

                    svf::State[numSVFs] svfStates;
                    svf::Coeffs[numSVFs] svfCoeffs;
                    onepole::State onepoleState;
                    onepole::Coeffs onepoleCoeffs;

                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
                            let clippedFrequency = clamp (float64 (frequency),
                                                          float64 (minFreqHz),
                                                          processor.frequency * normalisedFreqLimit);
                            update (svfCoeffs, onepoleCoeffs, processor.frequency, order, clippedFrequency);
                        }

                        loop (updateInterval)
                        {
                            out << process (in, svfStates, svfCoeffs, onepoleState, onepoleCoeffs, mode, oddOrder);
                            advance();
                        }
                    }
                }
            }
        }

        //==============================================================================
        /**
            4th-order Linkwitz-Riley crossover filter, which outputs two bands of audio.

            The channels should sum together to produce a flat response.
            This filter is suitable for modulation.
        */
        namespace crossover
        {
            /** Holds the filter state. */
            struct State
            {
                svf::State svf1, svf2;
            }

            /** Holds a set of filter coefficients. */
            struct Coeffs
            {
                svf::Coeffs svf1, svf2;
            }

            /** */
            processor Processor (float initialFrequency = defaultFreqHz)
            {
                input stream SampleType in;
                output stream SampleType lowOut;
                output stream SampleType highOut;

                input event float frequencyIn [[ name: "Split Frequency", min: minFreqHz, max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];

                event frequencyIn (float v) { frequency = v; recalc = true; }

                float frequency = initialFrequency;
                bool recalc = true;

                /** Updates a set of coefficients for the given settings. */
                void update (Coeffs& c, float64 sampleRate, float64 freqHz)
                {
                    c.svf1.update (sampleRate, freqHz, defaultQuality);
                    c.svf2.update (sampleRate, freqHz, defaultQuality);
                }

                SampleType[2] process (State& s, SampleType x, Coeffs& c)
                {
                    let svf1 = s.svf1.process (x, c.svf1);
                    let lpf1 = svf1[0], hpf1 = svf1[1], bpf1 = svf1[2];
                    let apf1 = lpf1 - SampleType (sqrt (2.0)) * bpf1 + hpf1;
                    let svf2 = s.svf2.process (lpf1, c.svf2);
                    let lpf2 = svf2[0];

                    return SampleType[2] (lpf2, apf1 - lpf2);
                }

                void run()
                {
                    State s;
                    Coeffs c;

                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
                            let clippedFrequency = clamp (float64 (frequency),
                                                          float64 (minFreqHz),
                                                          processor.frequency * normalisedFreqLimit);
                            update (c, processor.frequency, clippedFrequency);
                        }

                        loop (updateInterval)
                        {
                            let y = s.process (in, c);
                            lowOut  << y[0];
                            highOut << y[1];
                            advance();
                        }
                    }
                }
            }
        }

        //==============================================================================
        /** SVF EQ.

            Based on the work of Andy Simper:
            https://cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf

            This filter is suitable for modulation.
        */
        namespace simper_eq
        {
            /** Constants for use in specifying the filter mode. */
            namespace Mode
            {
                let lowpass   = 0;
                let highpass  = 1;
                let bandpass  = 2;
                let lowShelf  = 3;
                let highShelf = 4;
                let peaking   = 5;
                let notch     = 6;
                let allpass   = 7;
                let bell      = 8;
            }

            /** Holds a set of filter coefficients. */
            struct Coeffs
            {
                CoeffType a1, a2, a3;
                CoeffType m0, m1, m2;
            }

            /** Holds the filter state. */
            struct State
            {
                SampleType ic1eq, ic2eq;
            }

            /** Resets a filter state. */
            void reset (State& s)
            {
                s.ic1eq = SampleType();
                s.ic2eq = SampleType();
            }

            /** Updates a set of coefficients for the given settings. */
            void update (Coeffs& c, float64 sampleRate, int mode, float64 freqHz, float64 quality, float64 gain)
            {
                let w = CoeffType (tan (pi * freqHz / sampleRate));
                let k = CoeffType (1  / clamp (quality, 0.01, 100.0));

                if (mode == Mode::lowpass)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 0;
                    c.m1 = 0;
                    c.m2 = 1;
                }
                else if (mode == Mode::highpass)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = -k;
                    c.m2 = -1;
                }
                else if (mode == Mode::bandpass)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 0;
                    c.m1 = 1;
                    c.m2 = 0;
                }
                else if (mode == Mode::lowShelf)
                {
                    let A = CoeffType (pow (10.0, gain / 40.0));
                    let g = w / sqrt (A);
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = k * (A - 1);
                    c.m2 = (A * A - 1);
                }
                else if (mode == Mode::highShelf)
                {
                    let A = CoeffType (pow (10.0, gain / 40.0));
                    let g = w / sqrt (A);
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = A * A;
                    c.m1 = k * (1 - A) * A;
                    c.m2 = (1 - A * A);
                }
                else if (mode == Mode::peaking)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = -k;
                    c.m2 = -2;
                }
                else if (mode == Mode::notch)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = -k;
                    c.m2 = 0;
                }
                else if (mode == Mode::allpass)
                {
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = -2 * k;
                    c.m2 = 0;
                }
                else if (mode == Mode::bell)
                {
                    let A = CoeffType (pow (10.0, gain / 40.0));
                    let g = w;
                    c.a1 = 1 / (1 + g * (g + k));
                    c.a2 = g * c.a1;
                    c.a3 = g * c.a2;
                    c.m0 = 1;
                    c.m1 = k * (A * A - 1);
                    c.m2 = 0;
                }
            }

            /** */
            SampleType process (State& s, SampleType x, Coeffs& c)
            {
                let v0 = x;
                let v3 = v0 - s.ic2eq;
                let v1 = SampleType (c.a1 * s.ic1eq + c.a2 * v3);
                let v2 = SampleType (s.ic2eq + c.a2 * s.ic1eq + c.a3 * v3);
                s.ic1eq = SampleType (2.0 * v1 - s.ic1eq);
                s.ic2eq = SampleType (2.0 * v2 - s.ic2eq);
                return    SampleType (c.m0 * v0 + c.m1 * v1 + c.m2 * v2);
            }

            /** */
            processor Processor (int initialMode = 0,
                                 float initialFrequency = defaultFreqHz,
                                 float initialQuality = defaultQuality,
                                 float initialGain = defaultGain)
            {
                input stream SampleType in;
                output stream SampleType out;

                input event
                {
                    float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                    float qualityIn   [[ name: "Q",         min: 0.001,       max: 100.0,     init: defaultQuality ]];
                    float gainIn      [[ name: "Gain",      min: -36.0,       max: 36.0,      init: 0.0,           unit: "dB"]];
                    float modeIn      [[ name: "Mode",      min: 0,           max: 8,         init: 0,             text: "Lowpass|Highpass|Bandpass|LowShelf|HighShelf|Peaking|Notch|Allpass|Bell"]];
                }

                event frequencyIn (float v) { frequency = v; recalc = true; }
                event qualityIn   (float v) { quality = v; recalc = true; }
                event gainIn      (float v) { gain = v; recalc = true; }
                event modeIn      (float v) { mode = int (v); recalc = true; }

                float frequency = initialFrequency,
                        quality = initialQuality,
                           gain = initialGain;
                int mode = initialMode;
                bool recalc = true;

                void run()
                {
                    State s;
                    Coeffs c;

                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
                            let clippedFrequency = clamp (float64 (frequency),
                                                          float64 (minFreqHz),
                                                          processor.frequency * normalisedFreqLimit);
                            c.update (processor.frequency, mode, clippedFrequency, quality, gain);
                        }

                        loop (updateInterval)
                        {
                            out << s.process (in, c);
                            advance();
                        }
                    }
                }
            }
        }

    } // (namespace tpt)
}
