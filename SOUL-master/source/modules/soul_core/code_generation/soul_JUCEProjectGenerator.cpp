/*
    _____ _____ _____ __
   |   __|     |  |  |  |      The SOUL language
   |__   |  |  |  |  |  |__    Copyright (c) 2019 - ROLI Ltd.
   |_____|_____|_____|_____|

   The code in this file is provided under the terms of the ISC license:

   Permission to use, copy, modify, and/or distribute this software for any purpose
   with or without fee is hereby granted, provided that the above copyright notice and
   this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

namespace soul::cpp
{

struct JUCEExporter
{
    JUCEExporter() = default;

    std::vector<SourceFile> generate (const Program& program, CompileMessageList& messages, CodeGenOptions& options)
    {
        std::vector<SourceFile> files;

        if (options.classNamespace.empty())
            options.classNamespace = "soul_import";

        options.generateJUCEHeader = true;
        options.generateJUCECPP = false;
        auto headerContent = soul::cpp::generateCode (program, messages, options);

        options.generateJUCEHeader = false;
        options.generateJUCECPP = true;
        auto cppContent = soul::cpp::generateCode (program, messages, options);

        auto& mainProcessor = program.getMainProcessor();

        mainClassName = options.classNamespace.empty() ? options.className
                                                       : (options.classNamespace + "::" + options.className);
        projectSeed = program.getHash();

        for (auto& i : mainProcessor.inputs)
        {
            if (i->isStreamEndpoint()
                  && ! isParameterInput (i->getDetails())
                  && i->getFrameType().isFloatingPoint()
                  && i->getFrameType().isPrimitiveOrVector())
                needsMicrophone = true;

            if (isMIDIEventEndpoint (i->getDetails()))
                needsMIDI = true;
        }

        isSynth = needsMIDI && ! needsMicrophone;

        auto nameRoot = mainProcessor.getReadableName();
        nameRoot = choc::text::replace (nameRoot, "::", "_");

        projectName     = nameRoot;
        jucerFilename   = nameRoot + ".jucer";
        headerName      = nameRoot + ".h";
        cppName         = nameRoot + ".cpp";
        mainFileName    = "Main.cpp";

        files.push_back ({ "README.txt",  getREADME() });
        files.push_back ({ mainFileName,  getMainFileContent() });
        files.push_back ({ headerName,    headerContent });
        files.push_back ({ cppName,       cppContent });
        files.push_back ({ jucerFilename, getProjucerProject() });

        return files;
    }

private:
    std::string projectSeed, projectName, jucerFilename, headerName, cppName, mainFileName, mainClassName;
    bool needsMicrophone = false;
    bool isSynth = false, needsMIDI = false;

    //==============================================================================
    std::string getREADME() const
    {
        static constexpr auto text = R"readmetext(

This folder and its contents were auto-generated by the SOUL code-gen tools.

It contains the source code and project files that implement a SOUL Patch
as a pure-C++ JUCE project, ready to be natively compiled into various kinds
of plugin - e.g. VST, AudioUnit, AAX.

In order to build it, first get yourself an up-to-date copy of the JUCE
framework from https://juce.com

Then, simply run the Projucer, and use it to open the file JUCER_FILENAME.

Hit the "open in your IDE" button, and it should generate and open a suitable project
for your IDE, which will automatically build all the different types of plugin
and a standalone executable to test it without a DAW.

For help on installing JUCE and running the Projucer, see:
https://juce.com/learn/tutorials
https://docs.juce.com/master/tutorial_new_projucer_project.html

)readmetext";

        return choc::text::replace (choc::text::trimStart (text),
                                    "JUCER_FILENAME", jucerFilename);
    }

    //==============================================================================
    std::string getMainFileContent() const
    {
        static constexpr auto text = R"juceMainFile(
//      _____ _____ _____ __
//     |   __|     |  |  |  |        Auto-generated JUCE project
//     |__   |  |  |  |  |  |__      SOUL Version SOUL_VERSION
//     |_____|_____|_____|_____|     https://soul.dev
//

#include <JuceHeader.h>
#include <array>

#ifndef SOUL_CPP_ASSERT
 #define SOUL_CPP_ASSERT(x)  jassert (x)
#endif

#include "HEADER_NAME"
#include "CPP_NAME"

//==============================================================================
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MAIN_CLASS();
}
)juceMainFile";
        return choc::text::replace (choc::text::trimStart (text),
                                    "HEADER_NAME", headerName,
                                    "CPP_NAME", cppName,
                                    "MAIN_CLASS", mainClassName,
                                    "SOUL_VERSION", getLibraryVersion().toString());
    }

    //==============================================================================
    std::string getProjucerProject() const
    {
        static constexpr auto text = R"jucerxml(
<?xml version="1.0" encoding="UTF-8"?>

<JUCERPROJECT id="SHORT_ID_1" name="PROJECT_NAME" projectType="audioplug" jucerVersion="5.4.7" cppLanguageStandard="17"
              pluginCharacteristicsValue="PLUGIN_FLAGS" jucerFormatVersion="1">
  <MAINGROUP id="SHORT_ID_2" name="PROJECT_NAME">
    <GROUP id="{LONG_UUID_1}" name="Source">
      <FILE id="SHORT_ID_3" name="HEADER_NAME" compile="0" resource="0" file="HEADER_NAME"/>
      <FILE id="SHORT_ID_4" name="CPP_NAME" compile="0" resource="0" file="CPP_NAME"/>
      <FILE id="SHORT_ID_5" name="MAIN_FILE_NAME" compile="1" resource="0" file="MAIN_FILE_NAME"/>
    </GROUP>
  </MAINGROUP>
  <EXPORTFORMATS>
    <XCODE_MAC targetFolder="Builds/MacOSX" microphonePermissionNeeded="MIC_NEEDED">
      <CONFIGURATIONS>
        <CONFIGURATION isDebug="1" name="Debug" recommendedWarnings="LLVM"/>
        <CONFIGURATION isDebug="0" name="Release" recommendedWarnings="LLVM"/>
      </CONFIGURATIONS>
    </XCODE_MAC>
    <VS2019 targetFolder="Builds/VisualStudio2019">
      <CONFIGURATIONS>
        <CONFIGURATION isDebug="1" name="Debug"/>
        <CONFIGURATION isDebug="0" name="Release"/>
      </CONFIGURATIONS>
    </VS2019>
    <VS2017 targetFolder="Builds/VisualStudio2017">
      <CONFIGURATIONS>
        <CONFIGURATION isDebug="1" name="Debug"/>
        <CONFIGURATION isDebug="0" name="Release"/>
      </CONFIGURATIONS>
    </VS2017>
    <LINUX_MAKE targetFolder="Builds/LinuxMakefile">
      <CONFIGURATIONS>
        <CONFIGURATION isDebug="1" name="Debug" recommendedWarnings="GCC"/>
        <CONFIGURATION isDebug="0" name="Release" recommendedWarnings="GCC"/>
      </CONFIGURATIONS>
    </LINUX_MAKE>
  </EXPORTFORMATS>
  <MODULES>
    <MODULE id="juce_audio_basics" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_audio_devices" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_audio_formats" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_audio_plugin_client" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_audio_processors" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_audio_utils" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_core" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_data_structures" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_events" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_graphics" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_gui_basics" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
    <MODULE id="juce_gui_extra" showAllCode="1" useLocalCopy="0" useGlobalPath="1"/>
  </MODULES>
  <JUCEOPTIONS JUCE_VST3_CAN_REPLACE_VST2="0" JUCE_STRICT_REFCOUNTEDPOINTER="1"/>
</JUCERPROJECT>
)jucerxml";

        std::vector<std::string> pluginFlags;

        if (isSynth)    pluginFlags.push_back ("pluginIsSynth");
        if (needsMIDI)  pluginFlags.push_back ("pluginWantsMidiIn");

        auto s = choc::text::replace (choc::text::trimStart (text),
                                      "PROJECT_NAME", projectName,
                                      "HEADER_NAME", headerName,
                                      "MAIN_FILE_NAME", mainFileName,
                                      "CPP_NAME", cppName,
                                      "MIC_NEEDED", needsMicrophone ? "1" : "0",
                                      "PLUGIN_FLAGS", choc::text::joinStrings (pluginFlags, ","));

        for (int i = 0; i < 10; ++i)
            s = choc::text::replace (s,
                                     "SHORT_ID_" + std::to_string (i), createAlphaNumericUID (projectSeed + std::to_string (i)),
                                     "LONG_UUID_" + std::to_string (i), createGUID (projectSeed + std::to_string (i)));

        return s;
    }

    static std::string createAlphaNumericUID (const std::string& seed)
    {
        std::string uid;
        const char chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

        HashBuilder hash;
        hash << seed;
        auto hex = std::strtoull (hash.toString().c_str(), nullptr, 16);

        uid += chars[hex % 52]; // make sure the first character is always a letter
        hex >>= 6;

        for (int i = 5; --i >= 0;)
        {
            uid += chars[hex % 62];
            hex >>= 6;
        }

        return uid;
    }

    static std::string createGUID (const std::string& seed)
    {
        HashBuilder hash;
        hash << seed;

        auto hex = choc::text::toUpperCase (hash.toString());

        return hex.substr (0, 8)
             + "-" + hex.substr (8, 4)
             + "-" + hex.substr (12, 4)
             + "-" + hex.substr (16, 4)
             + "-" + hex.substr (20, 12);
    }
};

std::vector<SourceFile> generateJUCEProjectFiles (const Program& program, CompileMessageList& messages, CodeGenOptions& options)
{
    JUCEExporter e;
    return e.generate (program, messages, options);
}

}
