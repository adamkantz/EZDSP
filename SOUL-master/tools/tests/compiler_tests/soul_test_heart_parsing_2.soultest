/*
    _____ _____ _____ __
   |   __|     |  |  |  |      The SOUL language
   |__   |  |  |  |  |  |__    Copyright (c) 2019 - ROLI Ltd.
   |_____|_____|_____|_____|

   The code in this file is provided under the terms of the ISC license:

   Permission to use, copy, modify, and/or distribute this software for any purpose
   with or without fee is hereby granted, provided that the above copyright notice and
   this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

## error 1:1: error: Expected a valid version number after the #SOUL directive
#SOUL
namespace missingVersion {}

## error 1:7: error: Expected a valid version number after the #SOUL directive
#SOUL -1

processor test [[ main: true ]]
{
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 1:7: error: Cannot parse code that was generated by a later version of the API
#SOUL 2
namespace missingVersion {}

## error 3:1: error: Expected a graph, processor or namespace declaration
#SOUL 1

struct CantBeTopLeve
{
    float32[]  frames;
    float64    sampleRate;
}

## error 5:17: error: Expected a stream type specifier
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 5:23: error: Illegal array size
#SOUL 1

graph test [[ main: true ]]
{
    node gains = gain[60000];

    output  audioOut stream  float32;
}


## error 5:23: error: Illegal array size
#SOUL 1

graph test [[ main: true ]]
{
    node gains = gain[0];

    output  audioOut stream  float32;
}

processor gain [[ ]]
{
  output  audioOut stream float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 8:16: error: Cannot find symbol 'g'
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        return $g;
    }
}

## error 7:1: error: Found eof when expecting "{"
#SOUL 1

namespace tests
{
    function test1() -> int32

## error 15:16: error: Expected an expression of type bool
#SOUL 1

namespace tests
{
    function test1 (int32 $a) -> int32
    {
    @block_0:
        return $a;
    }

    function test2 () -> bool
    {
    @block_0:
        let $0 = call test1 (1);
        return $0;
    }
}

## error error: The function 'recursiveFunction' calls itself recursively
#SOUL 1

processor gain [[ main: true ]]
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      let $0 = call tests::recursiveFunction (1);
      write audioOut $0;
      advance;
      return;
  }
}

namespace tests
{
    function recursiveFunction (int32 $a) -> int32
    {
    @block_0:
        let $0 = call recursiveFunction ($a);
        return $0;
    }
}

## error error: The functions 'recursiveFunction1' and 'recursiveFunction2' call each other recursively
#SOUL 1

processor gain [[ main: true ]]
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      let $0 = call tests::recursiveFunction1 (1);
      write audioOut $0;
      advance;
      return;
  }
}

namespace tests
{
    function recursiveFunction1 (int32 $a) -> int32
    {
    @block_0:
        let $0 = call recursiveFunction2 ($a);
        return $0;
    }

    function recursiveFunction2 (int32 $a) -> int32
    {
    @block_0:
        let $0 = call recursiveFunction1 ($a);
        return $0;
    }
}

## error 7:24: error: Clock ratio out of range
#SOUL 1

graph main
{
  output  audioOut stream  int32;

  node Gain   = gain * - 5;

  connection none Gain.audioOut -> audioOut;
}

processor gain
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}


## compile
#SOUL 1

processor gain
{
  output  audioOut stream float32 [[ "a": _inf32, "b": _ninf32, "c": _nan32, "d": _inf64, "e": _ninf64, "f": _nan64 ]];

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 8:28: error: This value is too large to fit into an int32, did you mean to add an 'i64' suffix?
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = cast wrap<10000000000> (3);
        return $index;
    }
}

## error 8:22: error: Integer literal is too large to be represented
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        let $index = 10000000000000000000000;
        return $index;
    }
}

## error 9:18: error: Incompatible target type
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = 5;
        $index = 3.4;
        return $index;
    }
}


## error 9:23: error: Index is out of range
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = int32[4] {};
        return $index[10];
    }
}

## error 8:39: error: Found "," when expecting "}"
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = int32[4] { 1, 2, 3, 4, 5 };
        return $index[2];
    }
}

## error 8:26: error: Illegal size
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = int32[-4] { };
        return 3;
    }
}

## error 8:23: error: Cannot create an array with this element type
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = void[3] { };
        return 3;
    }
}

## error 8:23: error: Cannot create an array with this element type
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = void<3> { };
        return 3;
    }
}

## error 8:33: error: Illegal vector size
#SOUL 1

namespace tests
{
    function test1() -> int32
    {
    @block_0:
        $index = int32<1234567> { };
        return 3;
    }
}

## compile
#SOUL 1

namespace tests
{
    function test1() -> float64
    {
    @block_0:
        return 3;
    }
}

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 8:45: error: Cannot negate this type of constant
#SOUL 1

namespace tests
{
    function test1() -> bool
    {
    @block_0:
        let $0 = bool[3] {true, false, -true};
        return bool true;
    }
}

## error 9:14: error: Cannot find processor 'gain'
#SOUL 1

graph test
{
  output  audioOut stream  int32;

  node Gain = gain;

  connection none Gain.audioOut -> audioOut;
}

## error 10:14: error: Cannot find processor 'gain'
#SOUL 1

graph test
{
  output  audioIn stream  int32;
  output  audioOut stream  int32;

  node Gain = gain;

  connection none audioIn -> Gain.audioIn;
}

## error 11:3: error: The name 'DuplicateStructName' is already in use
#SOUL 1

namespace test
{
  struct DuplicateStructName
  {
      float64    sampleRate;
  }

  struct DuplicateStructName
  {
      float64    sampleRate;
  }
}

## error 9:3: error: The name 'duplicateFieldName' is already in use
#SOUL 1

namespace test
{
  struct MyStruct
  {
      float64    duplicateFieldName;
      float64    duplicateFieldName;
  }
}

## error 10:1: error: Expected a graph, processor or namespace declaration
#SOUL 1

namespace missingClosingBrace
{
  struct MyStruct
  {
      float64    duplicateFieldName;
  }

## error 10:1: error: Found eof when expecting "}"
#SOUL 1

namespace missingClosingBrace
{
  struct MyStruct
  {
      float64    duplicateFieldName;


## error 8:28: error: A processor with the name 'DuplicateNodeName' has already been declared
#SOUL 1

graph main
{
  output  audioOut stream  int32;

  node DuplicateNodeName   = gain;
  node DuplicateNodeName   = gain;

  connection none DuplicateNodeName.audioOut -> audioOut;
}

processor gain
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 9:14: error: A delay line length must be greater than zero
#SOUL 1

graph main
{
  output  audioOut stream  int32;

  node DuplicateNodeName   = gain;

  connection none DuplicateNodeName.audioOut -> [ 0 ] -> audioOut;
}

processor gain
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 9:14: error: Illegal delay line length
#SOUL 1

graph main
{
  output  audioOut stream  int32;

  node DuplicateNodeName   = gain;

  connection none DuplicateNodeName.audioOut -> [ 1234567890 ] -> audioOut;
}

processor gain
{
  output  audioOut stream  int32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}


## compile
#SOUL 1

processor gain
{
  output  audioOut1 stream float32 [[]];
  output  audioOut2 stream float32 [[ "defaultsToTrue" ]];

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 5:54: error: Missing annotation value
#SOUL 1

processor gain
{
  output  audioOut stream float32 [[ "missingValue": ]];

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 7:27: error: Cannot find processor 'Unknown'
#SOUL 1

graph main
{
  output  audioOut stream  int32;

  connection none Unknown.audioOut -> audioOut;
}


## error 14:1: error: Found eof when expecting "}"
#SOUL 1

processor gain [[ main: true ]]
{
  output  audioOut stream  int32;

  function stopsHalfWayThrough() -> void
  {
    @block_0:
      let $0 = call tests::recursiveFunction1 (1);
      write audioOut $0;


## error 17:7: error: Expected a statement
#SOUL 1

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }

  function _initialise() -> void
  {
    @block_0:
      45;
      return;
  }
}

## error 11:14: error: The name 'a' is already in use
#SOUL 1

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function run() -> void
  {
    @block_0:
      let $a = 4;
      let $a = 5;
      advance;
      return;
  }
}

## error 10:12: error: Unknown function: 'missingFunction'
#SOUL 1

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function run() -> void
  {
    @block_0:
      call missingFunction();
      advance;
      return;
  }
}

## error 16:12: error: Unknown function: 'wrongNumberOfArguments'
#SOUL 1

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function wrongNumberOfArguments(int32 $a) -> void
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      call wrongNumberOfArguments();
      advance;
      return;
  }
}

## error 17:12: error: Unknown function: 'wrongNumberOfArguments'
#SOUL 1

processor gain [[ main: true ]]
{
  output audioIn stream  float32;

  function wrongNumberOfArguments(int32 $a) -> void
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      let $a = float32<2> {1.0f, 2.0f};
      call wrongNumberOfArguments ($a);
      advance;
      return;
  }
}

## error 18:13: error: Streams are not available during init()
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }

  function init() -> void
  {
    @block_0:
      write audioOut 1.0f;
      return;
  }
}

## error 18:28: error: Streams are not available during init()
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }

  function init() -> void
  {
    @block_0:
      let $0 = read audioIn;
      return;
  }
}

## error 11:29: error: Cannot find input 'audioIn2'
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      let $0 = read audioIn2;
      advance;
      return;
  }
}

## error 11:23: error: Cannot find output 'audioOut2'
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      write audioOut2 1.0f;
      advance;
      return;
  }
}

## error 6:36: error: Only primitives or vectors supported by this endpoint type
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream float32[2];

  function run() -> void
  {
    @block_0:
      write audioOut 1.0f;
      advance;
      return;
  }
}

## error 6:42: error: Multiple data types not supported by this endpoint type
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream (float32, int32);

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 5:28: error: void is not a valid endpoint type
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream void;
  output audioOut stream float32;

  function run() -> void
  {
    @block_0:
      write audioOut 1.0f;
      advance;
      return;
  }
}

## error 6:60: error: Duplicate types found in type list: int32 and int32
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut event (float32, int32, float32<2>, int32);

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 6:59: error: void is not a valid endpoint type
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut event (float32, int32, float32<2>, void);

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 11:13: error: Endpoint index is not valid
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      write audioOut[2] 1.0f;
      advance;
      return;
  }
}


## error 6:37: error: Only primitives or vectors supported by this endpoint type
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32[2];

  function run() -> void
  {
    @block_0:
      write audioOut[2] 1.0f;
      advance;
      return;
  }
}

## error 9:21: error: Expected an array or vector type
#SOUL 1

namespace tests
{
  function test() -> void
  {
    @block_0:
      let $a = 0;
      let $b = $a[4];
      return;
  }
}

## error 11:13: error: Streams can only be read or written inside the run() function
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function test() -> void
  {
    @block_0:
      write audioOut 1.0f;
      return;
  }

  function run() -> void
  {
    @block_0:
      call test();
      advance;
      return;
  }
}

## error 11:14: error: The advance() function cannot be called inside this function
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function test() -> void
  {
    @block_0:
      advance;
      return;
  }

  function run() -> void
  {
    @block_0:
      call test();
      advance;
      return;
  }
}


## error 11:28: error: Streams can only be read or written inside the run() function
#SOUL 1

processor gain [[ main: true ]]
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function test() -> float32
  {
    @block_0:
      let $0 = read audioIn;
      return $0;
  }

  function run() -> void
  {
    @block_0:
      let $0 = call test();
      write audioOut $0;
      advance;
      return;
  }
}

## error 10:14: error: Cannot find source 'audioIn2'
#SOUL 1

graph test
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  node Gain = gain;

  connection none audioIn2 -> Gain.audioIn;
  connection none Gain.audioOut -> audioOut;
}

processor gain
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 11:14: error: Cannot find destination 'audioOut2'
#SOUL 1

graph test
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  node Gain = gain;

  connection none audioIn -> Gain.audioIn;
  connection none Gain.audioOut -> audioOut2;
}

processor gain
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 10:14: error: Cannot find destination 'Gain.audioIn2'
#SOUL 1

graph test
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  node Gain = gain;

  connection none audioIn -> Gain.audioIn2;
  connection none Gain.audioOut -> audioOut;
}

processor gain
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 11:14: error: Cannot find source 'Gain.audioOut2'
#SOUL 1

graph test
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  node Gain = gain;

  connection none audioIn -> Gain.audioIn;
  connection none Gain.audioOut2 -> audioOut;
}

processor gain
{
  input audioIn stream  float32;
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 10:13: error: This type is not supported by the endpoint
#SOUL 1

processor gain
{
  output audioOut stream  float32;

  function run() -> void
  {
    @block_0:
      write audioOut 1;
      advance;
      return;
  }
}

## error 10:13: error: This type is not supported by the endpoint
#SOUL 1

processor gain
{
  output audioOut[2] stream  float32;

  function run() -> void
  {
    @block_0:
      write audioOut[0] 1;
      advance;
      return;
  }
}


## error 9:23: error: The target for this expression is not an array
#SOUL 1

namespace tests
{
  function test() -> bool
  {
    @block_0:
      let $0 = 5;
      let $1 = $0[0:2];

      return equals ($1, 1);
  }
}

## error 9:23: error: Invalid array slice range
#SOUL 1

namespace tests
{
  function test() -> bool
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = $0[0:5];

      return equals ($1, 1);
  }
}

## error 9:23: error: Invalid arguments for the dot operator
#SOUL 1

namespace tests
{
  function test() -> bool
  {
    @block_0:
      let $0 = 56;
      let $1 = $0.blah;

      return equals ($1, 1);
  }
}

## error 14:23: error: No member called 'blah' found in struct 'MyType'
#SOUL 1

namespace tests
{
  struct MyType
  {
    int32 member;
  }

  function test() -> bool
  {
    @block_0:
      let $0 = MyType { 56 };
      let $1 = $0.blah;

      return equals ($1, 56);
  }
}

## error 9:24: error: Expected a constant value for the array size
#SOUL 1

namespace tests
{
  function test() -> bool
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = $0[0.6f:5];

      return equals ($1, 1);
  }
}

## error 9:28: error: Expected a constant value for the array size
#SOUL 1

namespace tests
{
  function test() -> bool
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = $0[0:"test"];

      return equals ($1, 1);
  }
}

## function
#SOUL 1

namespace tests
{
  function test1() -> bool
  {
    @block_0:
      let $0 = int32[3] { 1, 2, 3 };
      let $2 = $0[0:2];

      return equals ($2[0], 1);
  }

  function test2() -> bool
  {
    @block_0:
      let $0 = int32[3] { 1, 2, 3 };
      let $2 = $0[:2];

      return equals ($2[0], 1);
  }

  function test3() -> bool
  {
    @block_0:
      let $0 = int32[3] { 1, 2, 3 };
      let $2 = $0[1:];

      return equals ($2[0], 2);
  }
}

## error 9:22: error: Expected a constant value for the array size
#SOUL 1

namespace tests
{
  function test(int32 $i) -> void
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = $0[$i:];
      return;
  }
}

## error 9:25: error: An array index must be an integer type
#SOUL 1

namespace tests
{
  function test() -> void
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = $0["test"];
      return;
  }
}


## error 9:27: error: Illegal type for unary operator
#SOUL 1

namespace tests
{
  function test() -> void
  {
    @block_0:
      let $0 = int32[3] {1, 2, 3};
      let $1 = negate ($0);
      return;
  }
}

## error 8:20: error: Illegal types for binary operator '+' ('int32' and 'float32')
#SOUL 1

namespace tests
{
  function test() -> void
  {
    @block_0:
      let $0 = add (5, 6.7f);
      return;
  }
}

## error 8:27: error: Illegal types for binary operator '&&' ('int32' and 'int32')
#SOUL 1

namespace tests
{
  function test() -> void
  {
    @block_0:
      let $0 = logicalAnd (5, 7);
      return;
  }
}


## error 8:30: error: Index is out of range
#SOUL 1

namespace tests
{
    function testClamp() -> bool
    {
      @block_0:
        $clamp = clamp<10> 12;
        return bool true;
    }
}

## function
#SOUL 1

namespace tests
{
    function testFloat64() -> bool
    {
      @block_0:
        $v = float64 12;
        return equals ($v, 12.0);
    }

    function testFloat32() -> bool
    {
      @block_0:
        $v = float32 12;
        return equals ($v, 12.0f);
    }

    function testArray() -> bool
    {
      @block_0:
        $v = float64[5] 3.0;
        return equals ($v[2], 3.0);
    }

    struct MyStruct
    {
        int32 i;
    }

    function testStructArray() -> bool
    {
      @block_0:
        $v = MyStruct[2] {};
        return equals ($v[1].i, 0);
    }
}


## error 13:28: error: Expected an expression of type MyStruct
#SOUL 1

namespace tests
{
    struct MyStruct
    {
        int32 i;
    }

    function testVector() -> bool
    {
      @block_0:
        $v = MyStruct[2] { 1 };
        return equals ($v[1].i, 0);
    }
}

## error 13:26: error: Expected an expression of type MyStruct[2]
#SOUL 1

namespace tests
{
    struct MyStruct
    {
        int32 i;
    }

    function testVector() -> bool
    {
      @block_0:
        $v = MyStruct[2] 2;
        return equals ($v[1].i, 0);
    }
}

## error 8:29: error: Illegal size
#SOUL 1

namespace tests
{
    function testBoundedInt() -> bool
    {
      @block_0:
        let $a = clamp< -2> 4;
        return equals (cast int32 ($a), 4);
    }
}

## error error: Stack size limit exceeded - program requires 228.9 MB, maximum allowed is 20 MB
#SOUL 1

namespace tests
{
    function testTooLargeArray() -> void
    {
      @block_0:
        let $a = int64[30000000] {};
        return;
    }
}

## error error: Function testArray is empty
#SOUL 1

namespace tests
{
    function testArray() -> bool
    {
    }
}

## error 7:23: error: This latency value is out of range
#SOUL 1

processor test [[ main: true ]]
{
  output audioOut stream  float32;

  processor.latency = -5;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 7:23: error: This latency value is out of range
#SOUL 1

processor test [[ main: true ]]
{
  output audioOut stream  float32;

  processor.latency = 1000000;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 5:13: error: The name 'run' is not a valid endpoint name
#SOUL 1

processor Gain [[ main]]
{
  input run event float32;
  output  audioOut stream float32;

  event run (float32 $i)
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 6:14: error: The name 'run' is not a valid endpoint name
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output run stream float32;

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 8:13: error: The name 'run' is not a valid endpoint name
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  event run (float32 $f)
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## disabled error
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  event undefinedInput (float32 $f)
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 14:24: error: The name 'undefinedInput' is already in use
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  event undefinedInput (float32 $f)
  {
    @block_0:
      return;
  }

  event undefinedInput (float32 $f)
  {
    @block_0:
      return;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## disabled processor
#SOUL 1

graph test
{
  output out event int32;

  node eventGenerator = EventGenerator;
  node eventForwarder = EventForwarder;

  connection none eventGenerator.out -> eventForwarder.in;
  connection none eventForwarder.out -> out;
}

processor EventGenerator
{
  output out event int32;

  function run() -> void
  {
      @block_0:
          write out 1;
          advance;
          branch @loop_0;
      @loop_0:
          write out -1;
          advance;
          branch @loop_0;
  }
}

processor EventForwarder
{
  input in event int32;
  output out event int32;

  event in (float32 $i)
  {
    @block_0:
      write out cast int32 ($i);
      return;
  }
}

## error 11:5: error: The type 'MyStruct' cannot contain itself recursively
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  struct MyStruct
  {
    int32 i;
    MyStruct s;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 17:5: error: The types 'MyStruct2' and 'MyStruct' refer to each other recursively
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  struct MyStruct
  {
    int32 i;
    MyStruct2 s;
  }

  struct MyStruct2
  {
    int32 i;
    MyStruct s;
  }

  function run() -> void
  {
    @block_0:
      advance;
      return;
  }
}

## error 17:21: error: Unknown function: 'timesTwo'
#SOUL 1

processor Gain [[ main]]
{
  input audioIn event float32;
  output audioOut stream float32;

  function timesTwo (float32 $x) -> float32
  {
    @block_0:
    return multiply ($x, 2.0f);
  }

  function run() -> void
  {
    @block_0:
      let $x = call timesTwo (1.0f, 2.0f);
      advance;
      return;
  }
}
